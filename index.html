<!DOCTYPE html>
<html>
<body style="background-color:lightgrey">
<style>
	
</style>
<svg height="100%" width="100%" viewBox='-200 -100 400 200' style='position:static;background:lightgrey'>
	<g transform='scale(1,-1)'>
		<path d='M-200,-100h400v200h-400z' fill=none stroke=black stroke-width=1 />
	<g id='z1'></g>
	</g>
</svg>
	<br/>
	x pour commencer fleches pour bouger v pour changer de vue
	<div id='txts1'></div>
<script>
class Matrix{
	constructor(shape,det){
		/*
		[[,,,]
		[,,,]
		[,,,]
		[,,,]]
		
		
		*/
		this.shape=shape
		this.h=this.shape.length
		this.l=this.shape[0].length
		if(det==undefined){
			if(this.h==2 && this.l==2){
				this.det=this.get(1,1)*this.get(2,2)-this.get(2,1)*this.get(1,2);
			}
		}else{
			this.det=det
		}
		
	}
	get(x,y){
		return this.shape[y-1][x-1];
	}
	apply(f){
		for(let i=0;i<this.h;i++){
			for(let j=0;j<this.l;j++){
				this.shape[i][j]=f(this.shape[i][j])
			}
		}
	}
	static empty(h,l,n){
		var rep=[]
		for(let i=0;i<h;i++){
			rep.push([])
			for(let j=0;j<l;j++){
				rep[i].push(n);
			}
		}
		return (new Matrix(rep));
	}
	
	static plus(a,b){
		var rep=a.shape
		for(let i=0;i<a.h;i++){
			for(let j=0;j<a.l;j++){
				rep[i][j]=a.shape[i][j]+b.shape[i][j]
			}
		}
		return new Matrix(rep)
	}
	static times(a,b){
		var rep=Matrix.empty(a.h,b.l,0)
		
		for(let i=0;i<rep.h;i++){
			for(let j=0;j<rep.l;j++){
				var inul=0
				for(let n=0;n<a.l;n++){
					inul+=a.shape[i][n]*b.shape[n][j]
				}
				rep.shape[i][j]=inul;
			}
		}
		return rep;
	}
	inv(){
		var rep=[[0,0,0],[0,0,0],[0,0,0]]
		for(let i=1;i<4;i++){
			for(let j=1;j<4;j++){
				rep[i-1][j-1]=this.hors(i,j)*pairimpair(i+j);
			}
		}
		rep=new Matrix(rep);
		return rep
	}
	hors(x,y){
		var r=[[0,0],[0,0]];
		r[0][0]=this.get(notIn(x)[0],notIn(y)[0])
		r[1][0]=this.get(notIn(x)[0],notIn(y)[1])
		r[1][1]=this.get(notIn(x)[1],notIn(y)[1])
		r[0][1]=this.get(notIn(x)[1],notIn(y)[0])
		r=new Matrix(r);		
		return r.det;
	}
}
function notIn(n){
	if(n==1){
		return [2,3]
	}else if(n==2){
		return [1,3]
	}else{
		return [1,2]
	}
}
function pairimpair(n){
	if(n%2==0){
		return 1
	}else{
		return -1;
	}
}
function copy(o) {
   var output, v, key;
   output = Array.isArray(o) ? [] : {};
   for (key in o) {
       v = o[key];
       output[key] = (typeof v === "object") ? copy(v) : v;
   }
   return output;
}
function aff(txt,id){
	document.getElementById(id).innerHTML=txt;
}
function affP(txt,id){
	document.getElementById(id).innerHTML+=txt;
}
function clear(id){
	aff("",id);
}
function dist(x1,y1,x2,y2){
	return Math.sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
}
function dist3d(x1,y1,z1,x2,y2,z2){
	return Math.sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)+(z2-z1)*(z2-z1));
}
function cartPol(x,y){
	var d=dist(0,0,x,y)
	var ang=Math.acos(x/d)
	if(y<0){
		ang=-ang
	}
	if((x==0 && y==0) || ang=='NaN'){
		ang=0
	}
	return {r:d,ang:ang};
}
function polCart(r,ang){
	var x=Math.cos(ang)*r
	var y=Math.sin(ang)*r
	return {x:x,y:y};
}
for(i=0;i<10;i++){
	document.getElementById("txts1").innerHTML+='<div id='+i+"></div>"
}
var keysPressed={}
document.onkeydown=kd
document.onkeyup=ku
function kd(e){
	keysPressed[e.key]=1
	if(e.key=="x"){
		go=(go+1)%2;
		if(go==1){
			actufps()
			main()
			
		}
	}else if(e.key=='v'){
		if(cam.style=='normal'){
			cam.style='following'
		}else if(cam.style=='following'){
			cam.style='fpv'
		}else{
			cam.style='normal'
		}
	}
}
function ku(e){
	keysPressed[e.key]=undefined
}
function line(x1,y1,x2,y2){
	affP('<line x1='+x1+' y1='+y1+' x2='+x2+' y2='+y2+' stroke=black stroke-width=1 />',"z1");
}
class PtPol{
	constructor(r,phi,theta){
		
		this.phi=phi
		this.theta=theta
		this.r=r
	}
	cart(){
		var inu=polCart(this.r,this.phi)
		var diag=inu.x
		var inu2=polCart(diag,this.theta)
		
		return new PtCart(inu2.y,inu.y,inu2.x)
	}
}
class PtCart{
	constructor(x,y,z){
		this.x=x
		this.y=y
		this.z=z
	}
	pol(){
		var d=dist3d(0,0,0,this.x,this.z,this.y)
		var phi=Math.asin(this.y/d)
		var theta=cartPol(this.z,this.x).ang
		return new PtPol(d,phi,theta)
	}
}
function p(x,y,z){
	return new PtCart(x,y,z)
}
class Model{
	static list={}
	constructor(pts,l,c,st,name){
		this.pts=pts
		this.l=l
		this.st=st
		this.c=c
		Model.list[name]=this;
	}
	instance(x,y,z,phi,theta,tor){
		var l1=[]
		var l2=[]
		var l3=[]
		for(let i=0;i<this.pts.length;i++){
			l1.push(this.pts[i].x)
			l2.push(this.pts[i].y)
			l3.push(this.pts[i].z)
		}
		var rep=new Matrix([l1,l2,l3])
		var py,px,pz
		//torsion
		py=new PtPol(1,Math.PI/2+tor,Math.PI/2)
		px=new PtPol(1,tor,Math.PI/2)
		py=py.cart()
		px=px.cart()
		var mtor=new Matrix([[px.x,py.x,0],
							 [px.y,py.y,0],
							 [px.z,py.z,1]])
		rep=Matrix.times(mtor,rep)
		//phi
		py=new PtPol(1,Math.PI/2+phi,0)
		pz=new PtPol(1,phi,0)
		py=py.cart()
		pz=pz.cart()
		var mphi=new Matrix([[1,py.x,pz.x],
							 [0,py.y,pz.y],
							 [0,py.z,pz.z]])
		rep=Matrix.times(mphi,rep)
		//theta
		px=new PtPol(1,0,Math.PI/2+theta)
		pz=new PtPol(1,0,theta)
		px=px.cart()
		pz=pz.cart()
		var mtheta=new Matrix([[px.x,0,pz.x],
							 [px.y,1,pz.y],
							 [px.z,0,pz.z]])
		rep=Matrix.times(mtheta,rep)
		
		//constru
		var repfin=[]
		for(let pg=0;pg<this.pts.length;pg++){
			repfin.push(p(rep.shape[0][pg]+x,rep.shape[1][pg]+y,rep.shape[2][pg]+z))
		}
		return new Inst(repfin,this.l,this.st,this.c)
	}
}
class Inst{
	constructor(pts,l,st,c){
		this.pts=pts
		this.l=l
		this.c=c
		this.st=st
	}
	aff(){
		engine(this.pts,this.l,this.c,this.st)
	}
}
function rot(x,y,ang){
	var inu=cartPol(x,y)
	var inu2=polCart(inu.r,inu.ang+ang)
	return inu2
}
class Roue{
	constructor(){
		this.x=0
		this.z=0
		this.psX=0
		this.psZ=0
		this.ang=0
	}
	actu(){
		var vel=rot(this.x,this.z,-this.ang+Math.PI/2)
		
		if(frictionactiv==1){
			vel.y/=1.02
			vel.x/=1.001	
		}
		
		var fin=rot(vel.x,vel.y,this.ang-Math.PI/2)
		
		this.x=fin.x
		this.z=fin.y
		
		
		this.psX+=this.x
		this.psZ+=this.z
	}
}

new Model([p(-5,0,10),p(-5,0,-10),p(5,0,-10),p(5,0,10),p(-5,10,5),p(-5,10,-10),p(5,10,-10),p(5,10,5),p(-5,5,7),p(5,5,7),p(-5,4,10),p(5,4,10)],[[0,1,2,3,0],[4,5,6,7,4],[4,8,9,7],[9,11,10,8],[0,10],[3,11],[2,6],[1,5]],'black',0.5,'car')
//grille
var a=[]
var b=[]
for(let k=0;k<81;k++){
	a.push(p(-400,0,-k*10+400))
	a.push(p(400,0,-k*10+400))
	a.push(p(-k*10+400,0,400))
	a.push(p(-k*10+400,0,-400))
	b.push([k*4,k*4+1])
	b.push([k*4+2,k*4+3])
}
new Model(a,b,'blue',0.1,'grille')
new Model([p(0,0,2),
		   p(0,0,-2),
		   ],[[0,1]],'red',1,'roue')
new Model([p(-4,0,2),p(-4,0,-2),p(4,0,2),p(4,0,-2)],[[0,1],[3,2]],"red",1,'rouesarr')
//trace
var trace=new Inst([p(4,0,8),p(-4,0,8),p(4,0,-8),p(-4,0,-8)],[[0],[1],[2],[3]],0.2,'red')
var go=0;
var cam={psX:0,psY:100,psZ:-200,phireg:-Math.PI/8,thetareg:0,DE:200,vit:0.01,vitreg:0.0004,x:0,y:0,z:0,grav:-0.0,tv:0,pv:0,style:"normal"}//DE=dist ecran
var grille=Model.list["grille"].instance(0,0,0,0,0,0)
var car=Model.list['car'].instance(50,5,0,0,0,0)
let fps=0
let fps2=0
function actufps(){
	if(go==1){
		fps=fps2
		fps2=0
		setTimeout(function(){actufps();},1000);
		aff(fps,'1')
	}
}

	
var psX=0
var psY=0
var psZ=0
var y=0
var grav=-0.03
var theta=0
var phi=0
var r1=new Roue()
r1.psZ=8
r1.x=-1
var r2=new Roue()
r2.x=1
r2.psZ=-8
var frictionactiv=1
var time=0
main()
function main(){
	time++
	fps2++
	aff('',"z1")
	grille.aff()
	car=Model.list['car'].instance(psX,psY,psZ,phi,-theta,0)
	car.aff()
	var inuavga=rot(-4,7,r2.ang)
	var inuavdr=rot(4,7,r2.ang)
	var inuarga=rot(-4,-7,r2.ang)
	var inuardr=rot(4,-7,r2.ang)
	
	Model.list["roue"].instance(inuavga.x+psX,psY,inuavga.y+psZ,0,-r1.ang,0).aff()
	Model.list["roue"].instance(inuavdr.x+psX,psY,inuavdr.y+psZ,0,-r1.ang,0).aff()
	Model.list["rouesarr"].instance(r2.psX,psY,r2.psZ,0,-r2.ang,0).aff()
	//actu trace
	
	if(time%10==0){
		trace.pts.unshift(p(inuavga.x+psX,psY,inuavga.y+psZ))
		trace.l[0].push(trace.pts.length-1)
		trace.pts.unshift(p(inuavdr.x+psX,psY,inuavdr.y+psZ))
		trace.l[1].push(trace.pts.length-1)
		trace.pts.unshift(p(inuarga.x+psX,psY,inuarga.y+psZ))
		trace.l[2].push(trace.pts.length-1)
		trace.pts.unshift(p(inuardr.x+psX,psY,inuardr.y+psZ))
		trace.l[3].push(trace.pts.length-1)
		if(trace.pts.length>300){
			trace.l[0].pop()
			trace.l[1].pop()
			trace.l[2].pop()
			trace.l[3].pop()
			trace.pts.pop()
			trace.pts.pop()
			trace.pts.pop()
			trace.pts.pop()
			
		}
		
	}
	trace.aff()
	
	
	r1.ang=theta
	r2.ang=theta
	
	if(keysPressed.ArrowLeft==1){
		r1.ang+=Math.PI/4
	}
	if(keysPressed.ArrowRight==1){
		r1.ang-=Math.PI/4
	}
	
	y+=grav
	psY+=y
	phi=0
	
	if(psY<0){
		psY=0
		y=0
		if(keysPressed[" "]==1){
			y=1.75
		}
		if(keysPressed.ArrowUp==1){
			var inu=polCart(0.02,r2.ang)
			r2.x+=-inu.y
			r2.z+=inu.x
		}
		if(keysPressed.ArrowDown==1){
			var inu=polCart(-0.02,r2.ang)
			r2.x+=-inu.y
			r2.z+=inu.x
		}
		frictionactiv=1
	}else{
		frictionactiv=0
	}
	
	
	
	r1.actu()
	r2.actu()
	//compensation
	var milieu={x:(r1.psX+r2.psX)/2,z:(r2.psZ+r1.psZ)/2}
	var d=dist(r1.psX,r1.psZ,r2.psX,r2.psZ)
	r1.psX=milieu.x+(r1.psX-milieu.x)*16/d
	r1.psZ=milieu.z+(r1.psZ-milieu.z)*16/d
	r2.psX=milieu.x+(r2.psX-milieu.x)*16/d
	r2.psZ=milieu.z+(r2.psZ-milieu.z)*16/d
	psX=milieu.x
	psZ=milieu.z
	theta=cartPol(r1.psX-milieu.x,r1.psZ-milieu.z).ang-Math.PI/2
	
	//comp vels
	var direc=cartPol(r1.psX-r2.psX,r1.psZ-r2.psZ)
	var vel1={x:r1.x,z:r1.z}
	var vel2={x:r2.x,z:r2.z}
	var vel1b=cartPol(vel1.x,vel1.z)
	var vel2b=cartPol(vel2.x,vel2.z)
	var vel1c=polCart(vel1b.r,vel1b.ang-direc.ang)
	var vel2c=polCart(vel2b.r,vel2b.ang-direc.ang)
	var fall=vel2c.x+vel1c.x
	var inu=vel2c.x
	vel2c.x=vel1c.x
	vel1c.x=inu
	var vel1d=cartPol(vel1c.x,vel1c.y)
	var vel2d=cartPol(vel2c.x,vel2c.y)
	var vel1e=polCart(vel1d.r,vel1d.ang+direc.ang)
	var vel2e=polCart(vel2d.r,vel2d.ang+direc.ang)
	r1.x=vel1e.x
	r1.z=vel1e.y
	r2.x=vel2e.x
	r2.z=vel2e.y
	
	
	
	if(cam.style=='normal'){
		cam.psX+=(psX-cam.psX)/20
		cam.psZ+=((psZ-200)-cam.psZ)/20
		cam.psY+=((psY+100)-cam.psY)/20
		cam.phireg=-Math.PI/8
		cam.thetareg=0
	}else if(cam.style=='following'){
		var inu=new PtPol(-220,-Math.PI/8,-theta)
		inu=inu.cart()
		cam.psX+=((inu.x+psX)-cam.psX)/30
		cam.psY+=((inu.y+psY)-cam.psY)/30
		cam.psZ+=((inu.z+psZ)-cam.psZ)/30

		inu=new PtCart(psX-cam.psX,psY-cam.psY,psZ-cam.psZ)
		inu=inu.pol()
		cam.thetareg=inu.theta
		cam.phireg=inu.phi
	}else{
		var inu=new PtPol(50,phi+Math.PI/1.2,-theta)
		inu=inu.cart()
		cam.psX=inu.x+psX
		cam.psY=inu.y+psY+5
		cam.psZ=inu.z+psZ
		cam.thetareg=-theta
		cam.phireg=-Math.PI/10
		
	}
	
	
	if(go==1){
		setTimeout(function(){main();},0);
	}
}
function pos(n){
	if(n<0){
		return -n
	}else{
		return n
	}
}
function engine(pts,l,c,st){
	affAll(trucs3d(pts),l,c,st);
}
function affAll(pts,l,c,st){
	//faire un path
	var rep="<path fill=none stroke="+c+" stroke-width="+st+" d='";
	for (let i=0; i<l.length;i++){
		var inu=l[i]
		for(let b=0;b<inu.length-1;b++){
			var inu1=pts[inu[b]];
			var inu2=pts[inu[b+1]];
			if(inu1.length==2 && inu2.length==2){
				rep+="M"+inu1[0]+','+inu1[1]+'L'+inu2[0]+','+inu2[1]
			}else if(inu1.length==3 && inu2.length==2){
				rep+="M"+inu2[0]+','+inu2[1]+'L'
				var di=dist(inu1[0],inu1[1],inu2[0],inu2[1]);
				let inux=inu2[0]-(inu1[0]-inu2[0])*500/di
				let inuy=inu2[1]-(inu1[1]-inu2[1])*500/di
				
				rep+=inux+','+inuy
			}else if(inu1.length==2 && inu2.length==3){
				rep+="M"+inu1[0]+','+inu1[1]+'L'
				var di=dist(inu1[0],inu1[1],inu2[0],inu2[1]);
				let inux=inu1[0]-(inu2[0]-inu1[0])*500/di
				let inuy=inu1[1]-(inu2[1]-inu1[1])*500/di
				rep+=inux+','+inuy
			}
		}
	}
	rep+="' />"
	affP(rep,"z1")
		
}
	
function trucs3d(li){
	var repL=[]
	
	//calcul matrice transfo
	var inu=new PtPol(1,cam.phireg,cam.thetareg);
	var col3=inu.cart()
	inu=new PtPol(1,cam.phireg+Math.PI/2,cam.thetareg);
	var col2=inu.cart()
	inu=new PtPol(1,0,cam.thetareg+Math.PI/2)
	var col1=inu.cart()
	var m=new Matrix([[col1.x,col2.x,col3.x],[col1.y,col2.y,col3.y],[col1.z,col2.z,col3.z]],1)
	var invM=m.inv()
	
	let matP=[[],[],[]]
	for(let i=0;i<li.length;i++){
		let currP=li[i]
		let pm=new Matrix([[currP.x-cam.psX],[currP.y-cam.psY],[currP.z-cam.psZ]])
		let rep=Matrix.times(invM,pm)
		
		var repX=rep.shape[0][0]
		var repY=rep.shape[1][0]
		var f=rep.shape[2][0]
		repX=repX*cam.DE/f
		repY=repY* cam.DE/f
		
		
		if(f>0){
			repL.push([repX,repY])
		}else{
			repL.push([repX,repY,'no'])
		}
		
	}
	return repL
}

</script>
</body>
</html>
